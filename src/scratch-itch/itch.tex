%! suppress = FileNotFound
\documentclass[../main]{subfiles}

\begin{document}

\chapter{Itch: a testing framework for Scratch}\label{ch:itch}

Todo: introductie.

\section{Using the framework}\label{sec:itch-using-the-framework}

TODO

\section{Architectural design of the framework}\label{sec:itch-architecture}

TODO

\section{Test suites}\label{sec:itch-test-suites}

Test suites for Itch are written in JavaScript.
A test suite for Itch is split into three phases:

\begin{enumerate}
    \item The \term{before execution} phase, which is run before the execution of the Scratch project.
    \item The \term{during execution} phase, where the test suite controls the Scratch project and simulates user interaction.
    \item The \term{after execution} phase, where tests are run on the log, which was collected during the previous phase.
\end{enumerate}

All phases are optional, but a test suite without any phases will not test anything.
However, it is perfectly valid to not have a before execution, or only a before execution, depending on the types of tests you want to run.
They are implemented with ``magic'' functions: these have a fixed signature (name and arguments) and will be called in the relevant phases (\cref{lst:itch-test-suite-skeleton}).

\begin{listing}
    \begin{minted}{javascript}
/** @param {Evaluation} e */
function beforeExecution(e) {
    // Tests go here
}

/** @param {Evaluation} e */
function duringExecution(e) {
    // Tests go here
}

/** @param {Evaluation} e */
function afterExecution(e) {
    // Tests go here
}
    \end{minted}
    \caption[]{
        A skeleton of a test suite for Itch that shows the three phases.
        Each phase is implemented as separate function that will be called at the appropriate time by Itch.
        The argument to these functions is an instance of the \mintinline{javascript}{Evaluation} class, which provides various methods to help testing, such as the test structure, assertion functions, etc.
    }
    \label{lst:itch-test-suite-skeleton}
\end{listing}

Broadly, the tests can thus also be split according to their type: there are \term{static tests} and \term{dynamic tests}.
Static tests do not require execution of the Scratch project.
They are generally easier to write and faster to execute, but are severely limited in what they can test.
Assessing whether a project uses a certain block (e.g.\ a loop block) somewhere in the project is typically done with static tests.
Assessing whether a preprogrammed sprite (e.g.\ blocks that are provided in the starter project) was not modified is also done with static tests.
Static tests can be done completely in the before execution phase.

Checking more high-level goals, such as ``Does the sprite move when clicked?'', are more challenging with static tests.
At least, without severely limiting the accepted solutions.
For example, there are multiple ways to implement a sprite that moves when clicked, and a good test will want to accept all implementations.
For these kinds of behavioural tests, dynamic tests can be used.
These require the project to execute.
For these, the during and after execution phases are needed.
In the during execution phase, user interaction is simulated and the behaviour is captured.
This captured behaviour can then be inspected in the after execution phase to see if the actual behaviour matches with the required behaviour.

\subsection{Structure of a test suite}\label{subsec:structure-of-a-test-suite2}

A test suite consists of groups and tests, which can be nested.
A test suite consists of a hierarchical structure of groups and tests.
A test is a check on some property of the exercise.
It can be correct or wrong, and can contain feedback for both cases.
Additionally, a test also has a name and can include additional information, such as diffs, messages, etc.

Structure is added by grouping the tests into groups.
Groups can be nested, so groups inside groups etc.\ is possible.
While there is no hard limit, the recommendation is to not go deeper than three levels in most cases.

Groups are used for more than just structure.
They also support a notion of visibility, with three modes:

\begin{itemize}
    \item \emph{Visible}: the group is expanded (all children are visible).
    \item \emph{Hidden}: the group is completely hidden, unless one of the tests in the group fails.
    \item \emph{Summary}: the group is collapsed by default and a summary is shown unless one of the tests fails (in which case the group is expanded).
\end{itemize}

\begin{figure}
    \centering
    \begin{minted}{javascript}
        e.group.group('Tests for sprite A', () => {
          e.group
            .test('Sprite A does stuff right')
            .feedback({
              correct: 'Good job, sprite A does get stuff right!',
              wrong: 'Oh no, sprite A does not get it right, take another look.',
            })
           .expect('some value')
           .toBe('another value');
        });
    \end{minted}
    \caption{An example showing how the test suites are structured using groups and tests.}\label{fig:itch-test-suite-structure}
\end{figure}

Groups and tests in the JavaScript test suites are inspired by the Jest\footnote{\url{https://jestjs.io/}} testing framework.
The two relevant methods, \mintinline{javascript}{group} and \mintinline{javascript}{test} are available on the \mintinline{javascript}{Evaluation.group} property passed to the test suite.
\Cref{fig:itch-test-suite-structure} shows an example of this, containing a single test.
\marginnote{Backwards compatibility is one of the downsides of using software in production.}
The double \mintinline{javascript}{group.group} is not a typo, but needed for backwards compatibility with older test suites.
The test, as written in the example, will always fail, since it expects the string \mintinline{javascript}{"some value"} to be equal to \mintinline{javascript}{"another value"}.
The \mintinline{javascript}{expect}/\mintinline{javascript}{toBe} notation specifically will be familiar to Jest users.

Groups can be given just a name, as in the example, but it is also possible to provide more structured data to a group.
For example, it is possible to link a group to a certain sprite.
This information is also provided in the generated feedback, which means the code responsible for showing the feedback can, for example, show an image of the sprite with the group.

More details on how this structure is reflected in the generated feedback can be found in \cref{sec:format-of-the-generated-feedback}.
More metadata includes the visibility, a summary (used if the group's visibility is set to summary), some tags (which allows to tag groups with arbitrary strings), and an option to ignore wrong tests.
This last option means that if a test fails, it will be ignored completely and will not be outputted in the generated feedback.
This can be useful in cases where there are multiple possibilities: this allows trying each possibility until a passed test is found.

\subsection{Before execution}\label{subsec:before-execution}

The before execution phase allows for executing static tests.
Itch provides access to representations of two projects: the submission, created by the students, and the starter project, which is the project the students started with.

Providing both of these allows an easy way to assess whether some sprites, or blocks in a sprite, where modified by the students.
Itch provides helpers to ensure that students only modified certain sprites, or only certain code within sprites.
While this does limit the students in their ability to creatively modify the project, it makes behavioural tests for complex projects easier.
By limiting where the students are allowed to modify blocks, later tests can rely on certain functionality or sprites being available and working.
For example, if the project contains blocks that check if a sprite touches another sprite, these can be relied on.

This functionality of checking a set of predefined blocks and sprites is exposed with the function \mintinline{javascript}{Itch.checkPredefinedBlocks} to test suite authors.
For example:

\begin{minted}{javascript}
    Itch.checkPredefinedBlocks({
      spriteConfig: {
        SpriteA: script(whenIReceive('Start'), setEffectTo('brightness', 0)),
        SpriteB: {
          pattern: script(whenIReceive('Start'), setEffectTo('ghost', 0)),
          allowedBlocks: [forever()],
          allowAdditionalScripts: true,
        },
      },
      debug: false,
    }, e);
\end{minted}

The example above contains the test for two sprites.
All other sprites must be unchanged.

For the sprite \texttt{SpriteA}, students are allowed to change, add, or remove blocks in the script starting with the two blocks \scratchinline{\blockinit{when I receive \selectmenu{Start}}} and \scratchinline{\blocklook{set \selectmenu{ghost} effect to \ovalnum{0}}}.
Students are allowed to change blocks after these two predefined blocks.

The second sprite, \texttt{SpriteB}, allows modifications to scripts starting with the same blocks, but it uses the full version of the config object.
With the full version, it is also possible to also specify if additional scripts are allowed and limit the blocks they can use.
In this example, only the \scratchinline{\blockinfloop{forever}{\blockspace[0.2]}} block can be used (so this is not very useful test).
Finally, additional scripts (thus new ones created by the students) are also allowed.
These are free of restrictions: the check for allowed blocks does not apply.

\begin{figure}
    \centering
    \begin{wide}
        \begin{subfigure}{0.49\linewidth}
            \begin{scratch}[scale=0.8]
                \blockinit{when I receive \selectmenu{Start}}
                \blocklook{set \selectmenu{ghost} effect to \ovalnum{0}}
                \blockrepeat{repeat \ovalnum{15}}
                {
                    \blocklook{change size by \ovalnum{3}}
                    \blockmove{change y by \ovalnum{-2}}
                }
                \blockrepeat{repeat \ovalnum{15}}
                {
                    \blocklook{change \selectmenu{ghost} effect by \ovalnum{5}}
                    \blockmove{change size by \ovalnum{3}}
                }
                \blocklook{hide}

            \end{scratch}
            \caption{A script in Scratch.}
        \end{subfigure}
        \begin{subfigure}{0.5\linewidth}
            \begin{minted}{javascript}
            script(
              whenIReceive('Start'),
              setEffectTo(ghost(), 0),
              repeat(15, script(
                changeSizeBy(3),
                changeYBy(-2))
              ),
              repeat(20,script(
                changeEffectBy(ghost(), 5),
                changeSizeBy(3))
              ),
              hide(),
            );
            \end{minted}
            \caption{The equivalent in JavaScript.}
        \end{subfigure}
    \end{wide}
    \caption{An example of how a Scratch program can be represented using the abstractions provided by Itch.}\label{fig:itch-block-abstraction}
\end{figure}

Itch also includes an abstraction to represent Scratch blocks in JavaScript, as used in the example above.
For each Scratch block, a corresponding function exists (see an example in \cref{fig:itch-block-abstraction}).

The functions representing blocks can also be used to construct block patterns.
Two additional are provided for patterns.
The first is \mintinline{javascript}{anything()}, which can be used in any location (as a block, or value) and matches any block or value.
The reverse, \mintinline{javascript}{nothing()}, matches no block or value.
It can be useful to ensure that a script terminates (i.e.\ that there are no more blocks afterwards).
Additionally, an array of blocks or patterns can also be used in most places.
This represents a choice: it will match any of the patterns in the array.

For example, the pattern \mintinline{javascript}{repeat([15, 30], script(changeSizeBy(any()), never()))}, will match a \texttt{repeat} block that repeats 15 or 30 times, with a body with exactly one block, the \texttt{change size by} block, whose argument can be anything.

Since scripts form a tree of blocks, there are also helpers to match and test against a script of blocks.
This supports error messages for each block (meaning they each show up as a failed assertion in the output).

\subsection{During execution}\label{subsec:during-execution}

\begin{figure}
    \begin{minted}{javascript}
        /** @param {Evaluation} e */
        function duringExecution(e) {
          e.scheduler
           .greenFlag(true)
           .wait(800)
           .pressKey('s')
           .end();
        }
    \end{minted}
    \caption{An example of the during execution phase where the scheduler is used to first press the green flag, wait \qty{800}{\milli\second}, press the ``s'' key, and finally end execution.}\label{fig:itch-scheduler-example}
\end{figure}

The during execution phase is actually run just before the project is executed by Itch.
The main purpose of this phase is to use the \mintinline{javascript}{e.scheduler} (an instance of the \mintinline{javascript}{Scheduler} class) to schedule the execution of the project.
Using the scheduler, the test suite must specify how the project should be executed.
This includes starting execution, stopping execution, manipulating the Scratch Virtual Machine, and simulating user interaction, like clicking, key presses, input, and so on.
\Cref{fig:itch-scheduler-example} shows a minimal example of a schedule, where the green flag is pressed, some time must pass, and finally the ``s'' key is pressed.

The scheduler receives a set of actions to perform.
Each next action is executed after the previous one has been completed.
Because Scratch is a highly concurrent language, the scheduler also supports this.
First, most actions support a synchronous and asynchronous variant.
In the asynchronous variant, the action is executed and immediately finished.
For example, the action to press the green flag is almost instant: the green flag is pressed in the virtual machine, and the action is complete.

The synchronous actions will only finish after all activated scripts in Scratch have terminated.
For example, the action to press the green flag will wait on all scripts with a head block \scratchinline{\blockinit{when \greenflag clicked}} are done executing.
Of course, there are scenarios where this is not possible.
If one of the scripts contains an infinite loop (\scratchinline{\blockinfloop{forever}{\blockspace[0.2]}}), the next action would never be performed, as the script will never end.

Since the project that is run comes from students with unknown code, synchronous actions also support a timeout.
After this time has passed, a failed assertion will be added to the generated feedback, and the scheduler will continue.

Every action in the scheduler returns the last scheduled action: this return value can be used to schedule a next action after the previous one.
To create a non-linear schedule (e.g.\ multiple actions are performed simultaneously), there are a few options.
First, the return value of one of the previous actions can be used multiple times to schedule new actions.
All of these will be run in parallel.

% TODO: visualise this?

The other option is to use the method \mintinline{javascript}{forEach}: this is an implementation of the ``fold'' function on the events.
By deciding what event is used as the accumulator, either a linear (by returning the new action) or non-linear schedule (by returning the existing action) can be created.

While most actions are equivalent to their counter-parts in Scratch (like clicking a sprite, pressing a key, etc.), the wait action has more features.
In addition to waiting a set amount of time (like in the example), the wait action can also wait on the fulfillment of a certain condition.
The wait condition can be either waiting on a certain broadcast being sent, or a sprite fulfilling some condition.
The possible sprite conditions are moving, reaching a certain position, touching another sprite, no longer touching another sprite, touching the edge, and touching the mouse.
These conditions are added as needed, so with use, we envision more conditions being added.

A final special action is the \mintinline{javascript}{log} action.
This action saves the current state in the log (\cref{subsec:after-execution}) and executes a custom function at that time.
This action is intended to mark certain events in the log, but can also be used to execute a certain test during the execution of the project, instead of beforehand or afterwards.

\subsection{After execution}\label{subsec:after-execution}

\begin{figure}
    \begin{minted}{javascript}
        /** @param {Evaluation} e */
        function afterExecution(e) {
          // Get all click events on the Hat
          const clicks = e.log.events.filter((e) => e.type === 'click' && e.data.target === 'Hat');
          for (const cl of clicks) {
            const target = cl.data.target;
            const costumeNrBefore = cl.previous.target(target).currentCostume;
            const costumeNrAfter = cl.next.target(target).currentCostume;

            // Check that the costume cycles.
            const correctCostumeNr = (costumeNrBefore + 1) % 1;
            e.group.test('Click on Hat')
              .expect(costumeNrAfter)
              .toBe(correctCostumeNr);
          }
        }
    \end{minted}
    \caption{An after execution phase, where the log is used to check if the costume of the sprite ``Hat'' changes after each click (there are two costumes and the costumes need to cycle).}\label{fig:itch-hat-costum-change}
\end{figure}

The schedule from the during execution phase results in the project being executed.
During the execution, a log is constructed of the execution.
This is done by hand (using the \mintinline{javascript}{log} scheduler action) and automatically at interesting points.
The log consists of snapshots (which are taken every time something changes in the virtual machine) and events (which denote interesting snapshots).
For example, every action in the scheduler is saved as an event, meaning there is a snapshot before the action and after the action has been completed.

For example (\cref{fig:itch-hat-costum-change}), the action to click a sprite (which was scheduled in the previous phase) has a corresponding event in the log.
That event gives access to a snapshot from before the sprite was clicked and after the sprite was clicked (in this case, the scheduled action was synchronous).
In the actual test suite, the previous phase did not schedule one click, but a bunch of clicks.
Each of these events provides before and after snapshots, which are then used to determine if the costume changes as expected when the sprite was clicked.
As the example shows, the test suite is not concerned with the actual implementation in Scratch: the behaviour is tested.

\section{Evaluating projects}\label{sec:itch-evaluating-projects}

The evaluation of a submission goes through the following process:

\begin{enumerate}
    \item The submission, the starter project, and the test suite are made available (see later, as this depends on how Itch is run).
    \item Itch loads both projects, and runs the before execution phase.
    \item If the before execution phase does not result in an error, Itch initialises the virtual machine, inserts hooks for the log, and loads the submission into the virtual machine.
    \item The during execution phase is run, and the scheduled actions are captured from the test suite.
    \item Itch starts the virtual machine and executes the scheduled actions.
          While executing, the logs are captured.
    \item If the execution did not result in an error, Itch shuts down the virtual machine, and runs the after execution phase.
\end{enumerate}

Scratch is built using browser technologies.
For the full capabilities, it has to be run in the browser.
While the virtual machine is pure JavaScript and could thus run without a browser, the renderer is not: it uses the HTML canvas and WebGL technologies.
The renderer is used to calculate things like sprite collisions and checking if sprites touch certain colours.
While it is theoretically possible to create a renderer that does not use WebGL, this would be a big undertaking and imply a big maintenance burden.
The re-implemented renderer will have to be kept up to date with the upstream one and replicate all behaviour exactly.

For these reasons, there are two ways to run Itch:

\begin{itemize}
    \item As a library in the browser.
          This is useful for contexts where you already have a browser, e.g.\ running along the Scratch environment on the device of the student.
    \item As a command line tool.
          This is for cases where Itch runs as a service in the backend, e.g.\ to check submissions after students are done.
\end{itemize}

\subsection{Running Itch as a library}\label{subsec:running-itch-as-a-library}

\begin{figure}
    \begin{minted}{typescript}
        export interface EvalConfig {
          /** The submission sb3 data. */
          submission: ArrayBuffer;
          /** The starter project sb3 file. */
          template: ArrayBuffer;
          /** If the output should be partial or full. */
          fullFormat: boolean;
          /* The canvas for the renderer. */
          canvas: HTMLCanvasElement;
          /** The test suite to use. */
          testplan: string | TestplanSource;
          /** Callback for the results. */
          callback: OutputHandler;
          /** The language of the exercise. */
          language: string;
        }

        /** Run the judge. */
        export async function run(config: EvalConfig): Promise<void>;
    \end{minted}
    \caption{The exposed interface to run Itch. It consists of one function and a configuration object.}\label{fig:itch-library-interface}
\end{figure}

Itch consists of two JavaScript packages, of which the core package implements the testing framework itself.
This package can be loaded into the browser and run.
The exposed interface to run Itch is limited to one function and a configuration object (\cref{fig:itch-library-interface}).
Most of the options are self-explanatory, and the output format option is explained in \cref{sec:format-of-the-generated-feedback}.

\subsection{Running Itch as a command line tool}\label{subsec:running-itch-as-a-command-line-tool}

\begin{figure}
    \begin{wide}
        \includestandalone[width=\linewidth]{itch-sequence-diagram}
    \end{wide}
    \caption{Sequence diagram showing the process of evaluating a project with Itch. When run as a library, there is no itch core or Puppeteer.}\label{fig:itch-sequence-diagram}
\end{figure}

When there is no browser available, Itch provides a command line interface.
\marginnote{A headless browser is a full browser, but without user interface.}
In this mode, Itch will run a headless browser, load the projects and test suites, run the judge, and finally collect the results from the browser.
\Cref{fig:itch-sequence-diagram} shows the complete process.

First, the command line interface (\texttt{itch-runner}) launches a Puppeteer instance.
There is support for supplying an existing Puppeteer instance, which can be useful on servers.
Then, the evaluation is started.
The Puppeteer instance runs a script, which first launches \texttt{itch-core}.
The script calls Itch as it would be used as a library: the \mintinline{typescript}{run(config)} function is called.
This will first load the Scratch projects, using the virtual machine.
The phases are then executed, with the before and during execution phase going first.
The during execution phase results in a schedule, which is then run: the virtual machine is now active and runs the projects with the scheduled actions.
Finally, the after execution phase is run, with the log from the execution before.


\section{Format of the generated feedback}\label{sec:format-of-the-generated-feedback}

The format of the generated feedback is in structure very similar to the structure of the tests in the test suite (\cref{subsec:structure-of-a-test-suite}).
The three levels of the feedback are:

\begin{itemize}[nosep]
    \item \term{Judgement}: the top-level object of the feedback.
    \item \term{Group}: contains one or more tests or subgroups (equivalent to a group from the test suite). Each group has the same options as in the test suite (e.g.\ visibility, sprites).
    \item \term{Test}: one condition or requirement that is evaluated (equivalent to a test from the test suite).
\end{itemize}

When running Itch as a library, it is possible to provide a callback function that will be called when feedback is available.
There are two modes for this: the partial model or the full mode.
In the partial feedback mode, feedback is streamed to the callback: it is called whenever feedback is available.
In the full mode, the callback is called once at the end with a fully constructed feedback object that contains all feedback for the evaluation.

When running Itch on the command line, the feedback is outputted to the standard output stream (this is also possible when using Itch as a library).
Depending on the feedback mode, the format is slightly different.

\begin{figure}
    \begin{minted}{json}
        {"command": "start-judgement", "version": 2}
        {"command": "start-group", "name": "Check on existing code", "visibility": "summary"}
        {"command": "start-group", "name": "Stage", "sprite": "Stage", "visibility": "summary"}
        {"command": "start-test", "name": "Sprite exists"}
        {"command": "close-test", "feedback": "The sprite exists", "status": "correct"}
        {"command": "close-group"}
        {"command": "close-group"}
        {"command": "close-judgement"}
    \end{minted}
    \caption{Example of the output generated by Itch for a test suite with two nested groups, with one test. Note the similarity to \cref{lst:tested-output-example}.}\label{lst:itch-output-example-partial}
\end{figure}

The partial feedback format is very similar to the Dodona feedback format used by TESTed (\cref{subsec:dodona-output}).
An example of this feedback is given in \cref{lst:itch-output-example-partial}.
The format is newline-delimited JSON: JSON objects are separated by a newline, and each line is a valid JSON object.
The structure of the feedback is indicated by commands, with \texttt{start} commands to begin a new level in the hierarchy and \texttt{close} commands to finish a level.

In full feedback mode, the output is a single JSON object that represents a nested tree of the same feedback.

\section{Evaluation of the Itch framework}\label{sec:itch-evaluation}

TODO


\end{document}
